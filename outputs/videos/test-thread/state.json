[
    {
        "id": 1,
        "scene_plan": "Hook \u2013 Grab attention with a quick, relatable question and a flashing right\u2011triangle. Show a bold, simple visual of a right triangle and a question bubble asking the viewer if they know how to find a missing side. Use a bright, eye\u2011catching animation to keep viewers curious.",
        "script": "Narrator: \"Ever seen a triangle and wondered how to find a side you can't see? Let's unlock that mystery in a snap!\"",
        "storyboard": "The screen opens on a bright, single\u2011color right triangle centered in the middle. A bold question bubble pops up beside it, asking, \u201cEver seen a triangle and wondered how to find a side you can\u2019t see?\u201d As the narrator speaks, the triangle\u2019s right\u2011angled corner flashes in a rapid, eye\u2011catching pulse. The bubble follows the narrator\u2019s rhythm, shifting slightly to stay near the triangle while the text stays legible, inviting curiosity before the lesson begins.",
        "animation_instructions": "SETUP: - Triangle: right\u2011angled, white outline on a dark blue background, 3 units wide, 3 units tall. - Question bubble: white rounded rectangle with a thin black border, positioned to the right of the triangle, containing the script text. - Flashing effect: a subtle glow around the triangle\u2019s right\u2011angled corner. SEQUENCE: 1. Fade in the triangle (0.5s) \u2013 Sync: \u201cEver seen a triangle\u2026\u201d 2. Fade in the question bubble (0.5s, slightly delayed) \u2013 Sync: \u201c\u2026and wondered how to find a side you can\u2019t see?\u201d 3. Begin flashing loop on the right corner: 0.2s on, 0.2s off, repeat 3 times \u2013 Sync: \u201cLet\u2019s unlock that mystery in a snap!\u201d 4. Slight up\u2011and\u2011down bob of the bubble (0.3s) to maintain viewer focus \u2013 Sync: narrator\u2019s final phrase. 5. Pause 0.5s to let the message settle. END: - Keep the triangle and bubble on screen as the scene transitions to the next segment; do not clear the background.",
        "manim_code": "from manim import *\n\nclass VideoScene(Scene):\n    def construct(self):\n        # Set up the background\n        self.camera.background_color = \"#1a1a2e\"\n        \n        # Create the right triangle (3x3 units)\n        triangle = Polygon(\n            np.array([-1.5, 0, 0]),\n            np.array([1.5, 0, 0]),\n            np.array([-1.5, 3, 0]),\n            color=WHITE,\n            stroke_width=4\n        )\n        \n        # Create the question bubble\n        question_text = Text(\"Ever seen a triangle\\nand wondered how to\\nfind a side you\\ncan't see?\", \n                           font_size=24, color=BLACK)\n        bubble = RoundedRectangle(\n            width=question_text.width + 0.8,\n            height=question_text.height + 0.6,\n            corner_radius=0.3,\n            color=BLACK,\n            stroke_width=2,\n            fill_color=WHITE,\n            fill_opacity=1\n        )\n        question_text.move_to(bubble.get_center())\n        bubble_group = VGroup(bubble, question_text)\n        bubble_group.next_to(triangle, RIGHT, buff=1.2)\n        \n        # Create the flashing corner highlight - fix the Dot initialization\n        corner_dot = Dot(\n            point=triangle.get_vertices()[0],\n            radius=0.3,\n            color=YELLOW\n        )\n        corner_dot.set_opacity(0)\n        \n        # Position everything properly\n        full_group = VGroup(triangle, bubble_group)\n        full_group.scale_to_fit_width(11.5)\n        full_group.move_to(ORIGIN)\n        \n        # Animation sequence\n        # 1. Fade in triangle\n        self.play(FadeIn(triangle), run_time=0.5)\n        \n        # 2. Fade in question bubble\n        self.play(FadeIn(bubble_group), run_time=0.5)\n        \n        # 3. Flash the corner\n        for _ in range(3):\n            self.play(\n                corner_dot.animate.set_opacity(0.8),\n                run_time=0.2\n            )\n            self.play(\n                corner_dot.animate.set_opacity(0),\n                run_time=0.2\n            )\n        \n        # 4. Bob the bubble\n        self.play(\n            bubble_group.animate.shift(UP*0.2),\n            run_time=0.15\n        )\n        self.play(\n            bubble_group.animate.shift(DOWN*0.2),\n            run_time=0.15\n        )\n        \n        # 5. Pause\n        self.wait(0.5)",
        "audio_path": "",
        "video_path": ""
    },
    {
        "id": 2,
        "scene_plan": "Introduce the right triangle and the three sides. Draw a right triangle and automatically attach a square to each side. Color each square uniquely (blue for hypotenuse, green for base, red for height). Label the sides as \u2018a\u2019, \u2018b\u2019, and \u2018c\u2019 (c being the hypotenuse).",
        "script": "Narrator: \"Take any right triangle. Label the two short legs a and b, and the longest side \u2013 the hypotenuse \u2013 c. Now, put a square on each side. Notice how the area of each square equals the length of its side squared.\"",
        "storyboard": "A blank white backdrop opens. A crisp, isosceles right\u2011angled triangle slides into view from the center, its right angle positioned at the lower\u2011left corner. Immediately, three translucent squares appear\u2014each snugly hugging one side of the triangle. The square on the hypotenuse glows blue, the one on the base turns green, and the height\u2019s square lights up red. Each square\u2019s side length matches its attached triangle side. The labels \u201ca,\u201d \u201cb,\u201d and \u201cc\u201d float over the respective legs and hypotenuse, while a subtle shading highlights the hypotenuse. The camera steadies, preparing the scene for the narrator\u2019s explanation.",
        "animation_instructions": "SETUP: - Triangle: right\u2011angled, legs a (vertical) and b (horizontal), hypotenuse c (diagonal). - Squares: one per triangle side, initially invisible, sizes equal to side lengths. - Colors: hypotenuse square = BLUE, base square = GREEN, height square = RED. - Labels: Text objects \"a\", \"b\", \"c\" positioned above each side. - Background: plain white. SEQUENCE: 1. Show triangle \u2013 Fade in over 0.8s. # Sync: \u201cTake any right triangle.\u201d 2. Animate squares \u2013 Grow from side to side over 1s each, concurrently. # Sync: \u201cLabel the two short legs a and b\u2026\u201d 3. Color squares \u2013 Apply color fills instantly upon completion. # Sync: \u201c\u2026and the longest side \u2013 the hypotenuse \u2013 c.\u201d 4. Place labels \u2013 Fade in text above each side over 0.6s. # Sync: \u201cNow, put a square on each side.\u201d 5. Highlight area concept \u2013 Brief zoom on one square, display equation \u201carea = side\u00b2\u201d near it for 1.5s. # Sync: \u201cNotice how the area of each square equals the length of its side squared.\u201d 6. Brief pause \u2013 0.5s to let viewers absorb.  END: - Keep triangle with colored squares and labels on screen; clear any temporary annotations.",
        "manim_code": "from manim import *\n\nclass VideoScene(Scene):\n    def construct(self):\n        # Create right triangle with right angle at bottom-left\n        triangle = Polygon(\n            [-2, -2, 0],  # right angle vertex\n            [2, -2, 0],   # end of base\n            [-2, 2, 0],   # end of height\n            color=BLACK,\n            stroke_width=3\n        )\n        \n        # Create squares for each side\n        # Base square (horizontal side) - green\n        base_square = Square(\n            side_length=4,\n            color=GREEN,\n            fill_opacity=0.3,\n            stroke_width=2\n        ).move_to([0, -2, 0])\n        \n        # Height square (vertical side) - red\n        height_square = Square(\n            side_length=4,\n            color=RED,\n            fill_opacity=0.3,\n            stroke_width=2\n        ).move_to([-2, 0, 0])\n        \n        # Hypotenuse square (diagonal) - blue\n        hypotenuse_square = Square(\n            side_length=4*1.414,  # diagonal length\n            color=BLUE,\n            fill_opacity=0.3,\n            stroke_width=2\n        ).rotate(PI/4).move_to([1, 1, 0])\n        \n        # Scale down the hypotenuse square to match actual triangle side\n        hypotenuse_square.scale(0.707)  # 1/sqrt(2) to match triangle side\n        \n        # Labels for the sides using Text instead of MathTex\n        label_a = Text(\"a\", font_size=36, color=RED).next_to(height_square, LEFT, buff=0.2)\n        label_b = Text(\"b\", font_size=36, color=GREEN).next_to(base_square, DOWN, buff=0.2)\n        label_c = Text(\"c\", font_size=36, color=BLUE).move_to([0.5, 0.5, 0])\n        \n        # Ensure everything fits in frame\n        full_group = VGroup(triangle, base_square, height_square, hypotenuse_square, label_a, label_b, label_c)\n        full_group.scale_to_fit_width(11.5)\n        full_group.move_to(ORIGIN)\n        \n        # Animation sequence\n        # 1. Show triangle\n        self.play(FadeIn(triangle), run_time=0.8)\n        \n        # 2. Animate squares appearing\n        self.play(\n            GrowFromEdge(base_square, DOWN),\n            GrowFromEdge(height_square, LEFT),\n            GrowFromEdge(hypotenuse_square, DR),\n            run_time=1.0\n        )\n        \n        # 3. Labels appear\n        self.play(\n            FadeIn(label_a),\n            FadeIn(label_b),\n            FadeIn(label_c),\n            run_time=0.6\n        )\n        \n        # 4. Brief pause\n        self.wait(0.5)",
        "audio_path": "",
        "video_path": ""
    },
    {
        "id": 3,
        "scene_plan": "Show the area relationship. Animate the big square on side c shrinking and splitting into two smaller squares (on sides a and b) side by side, then recombine to show that the total area stays the same. Use a simple \u201carea\u2011equivalence\u201d animation to visually prove the theorem.",
        "script": "Narrator: \"If we compare areas, the big square on c covers the same space as the two smaller squares together. That means c\u00b2 = a\u00b2 + b\u00b2!\"",
        "storyboard": "The screen opens on a large, white square whose side is labeled \\(c\\). A soft blue glow highlights its area. The narrator\u2019s voice explains the area comparison. As the narration continues, the big square morphs into two side\u2011by\u2011side squares, one with side \\(a\\) and the other with side \\(b\\), each retaining the original blue glow. They slide outward and settle adjacent to each other. A quick overlay shows the combined area equals the original, then the two squares merge back into the single \\(c\\) square, confirming \\(c^2 = a^2 + b^2\\).",
        "animation_instructions": "SETUP:\n- BigSquare: Square with side c, filled white, labeled \"c\" in center.\n- SmallSquareA: Square with side a, filled light blue, labeled \"a\".\n- SmallSquareB: Square with side b, filled light green, labeled \"b\".\n- OverlayText: Text \"c\u00b2 = a\u00b2 + b\u00b2\" (hidden initially).\n\nSEQUENCE:\n1. Appear BigSquare centered on screen. # Sync: Narrator starts \"If we compare areas...\"\n   Duration: 1.0s\n2. Fade in OverlayText above BigSquare. # Sync: \"the big square on c covers...\"\n   Duration: 0.5s\n3. Transform BigSquare into SmallSquareA and SmallSquareB side by side:\n   - SmallSquareA slides left, SmallSquareB slides right, both emerging from BigSquare\u2019s center.\n   Duration: 2.0s # Sync: \"...the same space as the two smaller squares...\"\n4. Fade in combined area hint: a translucent gray overlay covering both small squares, labeled \"Total Area\". # Sync: \"That means...\"\n   Duration: 0.5s\n5. Highlight each small square\u2019s area by a subtle pulse; the sum of pulses equals the gray overlay\u2019s opacity. # Sync: \"c\u00b2 = a\u00b2 + b\u00b2!\"\n   Duration: 1.5s\n6. Merge SmallSquareA and SmallSquareB back into BigSquare: reverse step 3, smoothing the transition.\n   Duration: 2.0s # Sync: narration ends.\n7. Fade out OverlayText. # Sync: end of narration.\n   Duration: 0.5s\n\nEND:\n- Keep BigSquare on screen for potential next scene transition.\n- Clear SmallSquareA, SmallSquareB, and OverlayText.",
        "manim_code": "from manim import *\n\nclass VideoScene(Scene):\n    def construct(self):\n        # Constants for the squares\n        c = 3.0  # side length of big square\n        a = 2.0  # side length of first small square\n        b = 2.2  # side length of second small square\n\n        # Create the big square\n        big_square = Square(side_length=c, fill_color=WHITE, fill_opacity=0.8, stroke_width=2)\n        big_square_label = Text(\"c\", font_size=48)\n        big_square_label.move_to(big_square.get_center())\n\n        # Create small squares\n        small_square_a = Square(side_length=a, fill_color=BLUE, fill_opacity=0.8, stroke_width=2)\n        small_square_b = Square(side_length=b, fill_color=GREEN, fill_opacity=0.8, stroke_width=2)\n\n        # Labels for small squares\n        label_a = Text(\"a\", font_size=36)\n        label_a.move_to(small_square_a.get_center())\n        label_b = Text(\"b\", font_size=36)\n        label_b.move_to(small_square_b.get_center())\n\n        # Create overlay text\n        overlay_text = Text(\"c\u00b2 = a\u00b2 + b\u00b2\", font_size=36)\n        overlay_text.to_edge(UP)\n\n        # Position small squares for side-by-side view\n        small_square_a.shift(LEFT * (c/2 + a/4))\n        small_square_b.shift(RIGHT * (c/2 + b/4))\n        label_a.next_to(small_square_a, DOWN)\n        label_b.next_to(small_square_b, DOWN)\n\n        # Create area overlay\n        area_overlay = Rectangle(\n            width=a + b + 0.5,\n            height=max(a, b),\n            fill_color=GRAY,\n            fill_opacity=0.3,\n            stroke_width=0\n        )\n        area_overlay.move_to(VGroup(small_square_a, small_square_b).get_center())\n        area_label = Text(\"Total Area\", font_size=24)\n        area_label.move_to(area_overlay.get_center())\n\n        # Apply frame-fit rule\n        full_group = VGroup(big_square, big_square_label, small_square_a, small_square_b, label_a, label_b)\n        full_group.scale_to_fit_width(11.5)\n        full_group.move_to(ORIGIN)\n\n        # Animation sequence\n        # Step 1: Appear big square\n        self.play(FadeIn(big_square), Write(big_square_label), run_time=1.0)\n        self.wait(0.5)\n\n        # Step 2: Fade in overlay text\n        self.play(FadeIn(overlay_text), run_time=0.5)\n        self.wait(0.5)\n\n        # Step 3: Transform into two small squares\n        self.play(\n            Transform(big_square, VGroup(small_square_a, small_square_b)),\n            Transform(big_square_label, VGroup(label_a, label_b)),\n            run_time=2.0\n        )\n\n        # Step 4: Fade in area overlay\n        self.play(FadeIn(area_overlay), Write(area_label), run_time=0.5)\n\n        # Step 5: Highlight squares with pulse\n        self.play(\n            Indicate(small_square_a, scale_factor=1.1, run_time=0.75),\n            Indicate(small_square_b, scale_factor=1.1, run_time=0.75)\n        )\n        self.wait(0.5)\n\n        # Step 6: Merge back into big square\n        self.play(\n            Transform(VGroup(small_square_a, small_square_b), big_square),\n            Transform(VGroup(label_a, label_b), big_square_label),\n            FadeOut(area_overlay),\n            FadeOut(area_label),\n            run_time=2.0\n        )\n\n        # Step 7: Fade out overlay text\n        self.play(FadeOut(overlay_text), run_time=0.5)\n\n        self.wait(1.0)",
        "audio_path": "",
        "video_path": ""
    },
    {
        "id": 4,
        "scene_plan": "Derive the formula quickly and give a numeric example. Show a concrete triangle (a = 3, b = 4, c = 5). Write the equation 5\u00b2 = 3\u00b2 + 4\u00b2, then compute 25 = 9 + 16 to confirm it holds. Highlight the calculation steps with bright, animated numbers.",
        "script": "Narrator: \"Try 3\u20114\u20115: 5\u00b2 equals 25, and 3\u00b2 + 4\u00b2 is 9 + 16, which also equals 25. It checks out \u2013 that\u2019s the Pythagorean theorem in action!\"",
        "storyboard": "A bright, animated triangle with sides \\(a=3\\), \\(b=4\\), \\(c=5\\) appears, centered on the screen. The three sides are labeled with their lengths. A large equation \\(5^{2}=3^{2}+4^{2}\\) slides in below the triangle. The numbers 25, 9, and 16 glow one by one, each flaring and then shrinking as the narrator speaks. As the calculation \\(25=9+16\\) is read, the equals sign lights up, confirming the theorem. The scene ends with the triangle fading while the final result stays highlighted.",
        "animation_instructions": "SETUP:\n- Triangle (right\u2011angled) with vertices A(0,0), B(3,0), C(3,4); side labels: a=3, b=4, c=5\n- Equation text object: \u201c5\u00b2 = 3\u00b2 + 4\u00b2\u201d (initially transparent)\n- Sub\u2011expressions: 5\u00b2, 3\u00b2, 4\u00b2, 9, 16, 25 (separate MathTex objects, all initially invisible)\n- Equals sign \u201c=\u201d between terms\n\nSEQUENCE:\n1. Triangle fades in over 0.8s \u2013 Sync: \u201cTry 3\u20114\u20115\u201d\n2. Labels appear with a pop (scale from 0.5 to 1) over 0.5s \u2013 Sync: \u201c5\u00b2 = 3\u00b2 + 4\u00b2\u201d\n3. 5\u00b2 glows (color change to bright yellow) over 0.5s \u2013 Sync: \u201c5\u00b2 equals 25\u201d\n4. 3\u00b2 glows, then 4\u00b2 glows, each for 0.4s \u2013 Sync: \u201c3\u00b2 + 4\u00b2\u201d\n5. 9 and 16 appear sequentially, each animating from 0.2s scaling up, then fading to background color \u2013 Sync: \u201c9 + 16\u201d\n6. 25 appears, matches the 5\u00b2 value, both highlighted; equals signs light up \u2013 Sync: \u201cequals 25\u201d\n7. A quick glow ripple through the entire equation over 0.6s to emphasize the truth \u2013 Sync: \u201cIt checks out\u201d\n8. Triangle fades out slowly over 1s while equation remains on screen\n\nEND:\n- Keep the final equation \u201c5\u00b2 = 3\u00b2 + 4\u00b2\u201d and highlighted 25 for the next scene",
        "manim_code": "from manim import *\n\nclass VideoScene4(Scene):\n    def construct(self):\n        # Create triangle vertices\n        A = np.array([0, 0, 0])\n        B = np.array([3, 0, 0])\n        C = np.array([3, 4, 0])\n        \n        # Create triangle with proper right angle\n        triangle = Polygon(A, B, C, color=BLUE, stroke_width=4)\n        \n        # Create right angle indicator\n        right_angle = Square(side_length=0.3, color=WHITE, stroke_width=2)\n        right_angle.move_to([2.85, 0.35, 0])\n        \n        # Create side lines for positioning labels\n        side_a = Line(B, C)\n        side_b = Line(A, C)\n        side_c = Line(A, B)\n        \n        # Side labels using Text instead of MathTex\n        a_label = Text(\"a=3\", font_size=24).next_to(side_a, RIGHT, buff=0.2)\n        b_label = Text(\"b=4\", font_size=24).next_to(side_b, LEFT, buff=0.2)\n        c_label = Text(\"c=5\", font_size=24).next_to(side_c, DOWN, buff=0.2)\n        \n        # Group triangle and labels\n        triangle_group = VGroup(triangle, right_angle, a_label, b_label, c_label)\n        triangle_group.scale_to_fit_width(4)\n        triangle_group.move_to(ORIGIN)\n        \n        # Equation using Text with proper encoding\n        equation = Text(\"5^2 = 3^2 + 4^2\", font_size=36)\n        equation.next_to(triangle_group, DOWN, buff=0.8)\n        \n        # Calculation components\n        calc1 = Text(\"25 = 9 + 16\", font_size=36)\n        calc1.next_to(equation, DOWN, buff=0.5)\n        \n        # Position everything properly\n        full_group = VGroup(triangle_group, equation, calc1)\n        full_group.scale_to_fit_width(11.5)\n        full_group.move_to(ORIGIN)\n        \n        # Animation sequence\n        # 1. Triangle fades in\n        self.play(FadeIn(triangle_group), run_time=0.8)\n        self.wait(0.2)\n        \n        # 2. Labels appear with pop\n        self.play(\n            a_label.animate.scale(1.2),\n            b_label.animate.scale(1.2),\n            c_label.animate.scale(1.2),\n            run_time=0.25\n        )\n        self.play(\n            a_label.animate.scale(1/1.2),\n            b_label.animate.scale(1/1.2),\n            c_label.animate.scale(1/1.2),\n            run_time=0.25\n        )\n        \n        # 3. Equation appears\n        self.play(Write(equation), run_time=0.8)\n        \n        # 4. Glow 5^2\n        self.play(\n            equation[0:2].animate.set_color(YELLOW),\n            run_time=0.5\n        )\n        \n        # 5. Glow 3^2 and 4^2\n        self.play(\n            equation[5:7].animate.set_color(YELLOW),\n            equation[9:11].animate.set_color(YELLOW),\n            equation[0:2].animate.set_color(WHITE),\n            run_time=0.8\n        )\n        \n        # 6. Show calculations\n        self.play(\n            FadeIn(calc1),\n            equation[5:7].animate.set_color(WHITE),\n            equation[9:11].animate.set_color(WHITE),\n            run_time=0.8\n        )\n        \n        # 7. Highlight the results\n        self.play(\n            calc1[0:2].animate.set_color(YELLOW),  # 25\n            calc1[5:6].animate.set_color(GREEN),   # 9\n            calc1[8:10].animate.set_color(GREEN),   # 16\n            run_time=0.6\n        )\n        \n        # 8. Final emphasis\n        self.play(\n            calc1.animate.scale(1.1),\n            run_time=0.3\n        )\n        self.play(\n            calc1.animate.scale(1/1.1),\n            run_time=0.3\n        )\n        \n        # 9. Triangle fades out\n        self.play(\n            FadeOut(triangle_group),\n            run_time=1.0\n        )\n        \n        self.wait(0.5)",
        "audio_path": "",
        "video_path": ""
    },
    {
        "id": 5,
        "scene_plan": "Conclusion \u2013 Quick recap and real\u2011life relevance. Show a ladder leaning against a wall, a person walking across a bridge, or a GPS path. Summarize that the theorem lets us solve everyday distance problems and is the basis for many technologies like GPS, computer graphics, and engineering.",
        "script": "Narrator: \"So next time you\u2019re measuring a ladder, a roof, or a road, remember: a\u00b2 + b\u00b2 = c\u00b2. Pythagoras made geometry practical for the world around us.\"\n",
        "storyboard": "The scene opens with a realistic ladder propped against a wall; the narrator\u2019s words about measuring a ladder cue the image. As the equation \u201ca\u00b2 + b\u00b2 = c\u00b2\u201d appears in bold beneath the ladder, the camera zooms slightly to emphasize the relationship. The ladder then dissolves into a sleek bridge with a person walking across, illustrating \u201ca roof or a road.\u201d Finally, a stylized GPS path animates across the screen, connecting points like a real navigation route, while the narrator reminds viewers that Pythagoras made geometry practical for everyday life.",
        "animation_instructions": "SETUP:\n- Ladder: a rectangle with a slanted hypotenuse, colored brown, positioned in the left\u2011center of the frame.\n- Bridge: a straight horizontal line with a simple walkway overlay, colored steel gray, positioned in the right\u2011center.\n- Person: a small animated figure (dot or stick\u2011figure) walking across the bridge, moving rightward.\n- GPS Path: a curved dotted line starting at the left, ending at the right, with a moving dot (GPS icon) traversing it.\n- Text: equation \"a\u00b2 + b\u00b2 = c\u00b2\" in large, white font; subtitle \u201cPythagoras made geometry practical for the world around us.\u201d in smaller white font.\n- Background: light sky blue with subtle gradient.\n\nSEQUENCE:\n1. Fade in Ladder (1.5\u202fs) \u2013 Sync: \u201cSo next time you\u2019re measuring a ladder\u201d  \n2. Zoom in slightly on Ladder (0.5\u202fs) \u2013 Sync: \u201cremember: a\u00b2 + b\u00b2 = c\u00b2.\u201d  \n3. Fade in Text equation below Ladder (0.5\u202fs) \u2013 Sync: \u201ca\u00b2 + b\u00b2 = c\u00b2.\u201d  \n4. Fade out Ladder (1\u202fs) while simultaneously fade in Bridge (1\u202fs) \u2013 Sync: \u201ca roof or a road\u201d  \n5. Animate Person walking across Bridge (2\u202fs) \u2013 Sync: \u201ca roof or a road\u201d  \n6. Fade out Bridge & Person (0.5\u202fs) while fade in GPS Path (1\u202fs) \u2013 Sync: \u201cPythagoras made geometry practical\u201d  \n7. Animate GPS dot moving along path (3\u202fs) \u2013 Sync: \u201cPythagoras made geometry practical\u201d  \n8. Fade in Subtitle \u201cPythagoras made geometry practical for the world around us.\u201d below GPS Path (0.5\u202fs) \u2013 Sync: end of narration  \n\nEND:\n- Keep the GPS Path and Subtitle on screen for 1.5\u202fs to let the audience absorb the final message.  \n- Then fade all objects out (1\u202fs) to transition to next scene or end.",
        "manim_code": "from manim import *\n\nclass VideoScene(Scene):\n    def construct(self):\n        # Background\n        background = Rectangle(width=14, height=8, color=rgb_to_color([0.7, 0.85, 1.0]), fill_opacity=1)\n        self.add(background)\n\n        # Ladder setup\n        ladder_base = Rectangle(width=3, height=0.2, color=rgb_to_color([0.4, 0.2, 0.1]), fill_opacity=1)\n        ladder_base.move_to(LEFT * 3 + DOWN * 2)\n        \n        ladder_vertical = Rectangle(width=0.1, height=2.5, color=rgb_to_color([0.4, 0.2, 0.1]), fill_opacity=1)\n        ladder_vertical.move_to(LEFT * 4.5 + DOWN * 0.75)\n        \n        ladder_horizontal = Rectangle(width=2.5, height=0.1, color=rgb_to_color([0.4, 0.2, 0.1]), fill_opacity=1)\n        ladder_horizontal.move_to(LEFT * 3 + DOWN * 2)\n        \n        ladder_diagonal = Line(start=LEFT * 4.5 + DOWN * 2, end=LEFT * 3 + UP * 0.5, color=rgb_to_color([0.4, 0.2, 0.1]), stroke_width=8)\n        \n        ladder_group = VGroup(ladder_base, ladder_vertical, ladder_horizontal, ladder_diagonal)\n        \n        # Bridge setup\n        bridge = Rectangle(width=3, height=0.3, color=GRAY, fill_opacity=1)\n        bridge.move_to(RIGHT * 3 + DOWN * 2)\n        \n        bridge_walkway = Rectangle(width=2.8, height=0.1, color=WHITE, fill_opacity=1)\n        bridge_walkway.move_to(RIGHT * 3 + DOWN * 2)\n        \n        bridge_group = VGroup(bridge, bridge_walkway)\n        \n        # Person (dot)\n        person = Dot(point=RIGHT * 1.5 + DOWN * 2, color=BLUE, radius=0.15)\n        \n        # GPS path setup\n        gps_path = DashedVMobject(\n            ArcBetweenPoints(start=LEFT * 4, end=RIGHT * 4, angle=PI/4, color=WHITE, stroke_width=4),\n            num_dashes=20\n        )\n        \n        gps_dot = Dot(point=LEFT * 4 + DOWN * 0.5, color=RED, radius=0.12)\n        \n        # Text setup - using Text with regular characters\n        equation = Text(\"a2 + b2 = c2\", color=WHITE, font_size=48)\n        equation.next_to(ladder_group, DOWN, buff=0.5)\n        \n        subtitle = Text(\"Pythagoras made geometry practical for the world around us.\", color=WHITE, font_size=24)\n        subtitle.next_to(gps_path, DOWN, buff=0.8)\n        \n        # Apply global frame-fit rule\n        full_layout = VGroup(ladder_group, bridge_group, gps_path, equation, subtitle)\n        full_layout.scale_to_fit_width(11.5)\n        full_layout.move_to(ORIGIN)\n        \n        # Animation sequence\n        # 1. Fade in Ladder\n        self.play(FadeIn(ladder_group), run_time=1.5)\n        self.wait(0.5)\n        \n        # 2. Zoom in slightly on Ladder\n        self.play(ladder_group.animate.scale(1.1), run_time=0.5)\n        \n        # 3. Fade in Text equation below Ladder\n        self.play(FadeIn(equation), run_time=0.5)\n        self.wait(0.5)\n        \n        # 4. Fade out Ladder while simultaneously fade in Bridge\n        self.play(\n            FadeOut(ladder_group),\n            FadeOut(equation),\n            FadeIn(bridge_group),\n            run_time=1\n        )\n        \n        # 5. Animate Person walking across Bridge\n        self.play(person.animate.move_to(RIGHT * 4.5 + DOWN * 2), run_time=2)\n        \n        # 6. Fade out Bridge & Person while fade in GPS Path\n        self.play(\n            FadeOut(bridge_group),\n            FadeOut(person),\n            FadeIn(gps_path),\n            run_time=1\n        )\n        \n        # 7. Animate GPS dot moving along path\n        self.play(\n            MoveAlongPath(gps_dot, gps_path),\n            run_time=3\n        )\n        \n        # 8. Fade in Subtitle\n        self.play(FadeIn(subtitle), run_time=0.5)\n        self.wait(1.5)\n        \n        # End - fade all out\n        self.play(\n            FadeOut(gps_path),\n            FadeOut(gps_dot),\n            FadeOut(subtitle),\n            run_time=1\n        )",
        "audio_path": "",
        "video_path": ""
    }
]